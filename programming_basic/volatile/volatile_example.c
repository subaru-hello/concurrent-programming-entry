#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>

/*
 * 概要:
 * このプログラムはvolatile修飾子を使用して、複数のスレッド間で共有される変数の
 * 適切な扱い方を示す例です。volatile修飾子は、変数の値が予期せず変更される
 * 可能性があることをコンパイラに伝え、最適化による問題を防ぎます。
 * コンパイラは最適化のために、レジスタにコピー(キャッシュ)してから値を使う。(メモリアクセスはレジスタアクセスに比較して遅いため。)
 * 複数のプロセスが同一メモリにアクセスを行いたいときに、キャッシュが古いと問題を引き起こす時がある。その時にvolatileを使う。
 * 
 * volatile修飾子の役割:
 * 1. コンパイラの最適化を抑制し、変数へのアクセスが常に実際のメモリ読み書きを伴うようにします
 * 2. 複数のスレッドやプロセス、割り込みハンドラなどから変更される可能性のある変数に使用します
 * 3. キャッシュからではなく、常にメインメモリから値を読み込むようにします
 * 
 * 注意点:
 * volatileはスレッド間の同期を保証するものではありません。
 * 複数スレッドからの同時アクセスによる競合状態（race condition）は防げません。
 * 完全な同期にはミューテックスやアトミック操作などの同期プリミティブが必要です。
 * 
 * 処理内容:
 * 1. メインスレッドがvolatile変数を監視します
 * 2. 別のスレッドがその変数を変更します
 * 3. メインスレッドは変更を即座に検出します
 * 
 * コンパイル方法:
 * gcc -o volatile_example volatile_example.c -pthread
 *
 * 実行方法:
 * ./volatile_example
 * % ./volatile/volatile_example 
メインスレッド: カウンタースレッドを作成します
メインスレッド: 終了フラグが設定されるまで監視します
メインスレッド: カウンタの現在値: 0
カウンタースレッド: 開始します
カウンタースレッド: カウンタを増加させました: 1
メインスレッド: カウンタの現在値: 1
カウンタースレッド: カウンタを増加させました: 2
メインスレッド: カウンタの現在値: 2
メインスレッド: カウンタの現在値: 2
カウンタースレッド: カウンタを増加させました: 3
メインスレッド: カウンタの現在値: 3
メインスレッド: カウンタの現在値: 3
カウンタースレッド: カウンタを増加させました: 4
メインスレッド: カウンタの現在値: 4
メインスレッド: カウンタの現在値: 4
カウンタースレッド: カウンタを増加させました: 5
メインスレッド: カウンタの現在値: 5
メインスレッド: カウンタの現在値: 5
カウンタースレッド: カウンタを増加させました: 6
メインスレッド: カウンタの現在値: 6
メインスレッド: カウンタの現在値: 6
カウンタースレッド: カウンタを増加させました: 7
メインスレッド: カウンタの現在値: 7
メインスレッド: カウンタの現在値: 7
カウンタースレッド: カウンタを増加させました: 8
メインスレッド: カウンタの現在値: 8
メインスレッド: カウンタの現在値: 8
カウンタースレッド: カウンタを増加させました: 9
メインスレッド: カウンタの現在値: 9
メインスレッド: カウンタの現在値: 9
カウンタースレッド: カウンタを増加させました: 10
メインスレッド: カウンタの現在値: 10
メインスレッド: カウンタの現在値: 10
カウンタースレッド: 終了フラグを設定します
カウンタースレッド: 終了します
メインスレッド: 終了フラグが設定されました
メインスレッド: 最終的なカウンタの値: 10
メインスレッド: 終了します
 */

// volatileフラグ - スレッド間で共有される変数
volatile int should_exit = 0;

// カウンタ - 一方のスレッドが増加させ、もう一方が読み取る
volatile long counter = 0;

// スレッド用の関数 - カウンタを増加させる
void *counter_thread(void *arg) {
    printf("カウンタースレッド: 開始します\n");
    
    // カウンタを増加させる
    for (int i = 0; i < 10; i++) {
        counter++;  // volatileなので、この変更はメインメモリに即座に反映される
        printf("カウンタースレッド: カウンタを増加させました: %ld\n", counter);
        sleep(1);  // 1秒待機
    }
    
    // 終了フラグを設定
    printf("カウンタースレッド: 終了フラグを設定します\n");
    should_exit = 1;  // volatileなので、この変更はメインメモリに即座に反映される
    
    printf("カウンタースレッド: 終了します\n");
    pthread_exit(NULL);
}

int main() {
    pthread_t thread;
    int rc;
    
    printf("メインスレッド: カウンタースレッドを作成します\n");
    
    // スレッドを作成
    rc = pthread_create(&thread, NULL, counter_thread, NULL);
    if (rc) {
        printf("エラー: pthread_create() の戻り値は %d\n", rc);
        exit(-1);
    }
    
    printf("メインスレッド: 終了フラグが設定されるまで監視します\n");
    
    // volatileフラグが設定されるまで待機
    // volatileを使用しないと、コンパイラの最適化により
    // この無限ループが最適化され、フラグの変更を検出できない可能性がある
    while (!should_exit) {
        printf("メインスレッド: カウンタの現在値: %ld\n", counter);
        usleep(500000);  // 0.5秒待機
    }
    
    printf("メインスレッド: 終了フラグが設定されました\n");
    printf("メインスレッド: 最終的なカウンタの値: %ld\n", counter);
    
    // スレッドの終了を待機
    pthread_join(thread, NULL);
    
    printf("メインスレッド: 終了します\n");
    return 0;
}

/*
 * volatile修飾子の使用例と注意点:
 * 
 * 1. 適切な使用例:
 *    - 割り込みハンドラによって変更される変数
 *    - メモリマップドI/Oレジスタ
 *    - 複数のスレッドから読み書きされる単純なフラグ変数
 * 
 * 2. 不適切な使用例:
 *    - スレッド間の同期のみを目的とした場合（ミューテックスやセマフォを使用すべき）
 *    - アトミックな操作が必要な場合（std::atomic や pthread_atomic_* を使用すべき）
 * 
 * 3. volatileの限界:
 *    - メモリバリアを提供しない
 *    - アトミック操作を保証しない
 *    - キャッシュの一貫性を保証しない
 * 
 * 4. マルチスレッドプログラミングでの推奨事項:
 *    - 単純なフラグには volatile が適している場合もある
 *    - 複雑なデータ構造や操作には適切な同期プリミティブを使用する
 *    - 重要な同期には pthread_mutex_t や std::atomic を使用する
 */ 